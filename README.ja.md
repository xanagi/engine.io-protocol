# Engine.IO プロトコル

このドキュメントでは、Engine.IO プロトコルを説明します.参照 JavaScript 実装については、
[engine.io-parser](https://github.com/learnboost/engine.io-parser),
[engine.io-client](https://github.com/learnboost/engine.io-client)
および [engine.io](https://github.com/learnboost/engine.io).
を確認してください.

## リビジョン

これは Engine.IO プロトコルのリビジョン **3** です.

## Engine.IO セッションの仕組み

1. トランスポートが Engine.IO URL への接続を確立します.
2. サーバーが JSON エンコードされたハンドシェイクデータをセットした `open` パケットで応答を返します:
  - `sid` セッション ID (`String`)
  - `upgrades` 可能なトランスポートのアップグレード (`String` の `Array`)
  - `pingTimeout` サーバーで設定された ping タイムアウト. サーバーが
    応答を返さないことをクライアントが検知するために使われる (`Number`)
3. クライアントは、サーバーから定期的に送信される `ping` パケットに、`pong` パケットで
応答しなくてはなりません.
4. クライアントとサーバーは、`message` パケットを自由にやりとりすることができます.
5. pollling トランスポートは、常にオープンとクローズを繰り返しているようなものなので、
ソケットを閉じるために `close` パケットを送ることができます.

## URL

Engine.IO の URL は以下のように構成されます:

`/engine.io/` [ ? <クエリ文字列> ]

- `engine.io` というパス名は、engine.io プロトコル上に構築される、より上位のフレームワーク
によってのみ変更されるべきです.

- クエリ文字列はオプションで、4つの予約されたキーがあります:

  - `transport`: トランスポート名を示します. デフォルトでサポートされているトランスポートは、
    `polling`, `flashsocket`, `websocket` です.
  - `j`: トランスポートが `polling` で、JSONP レスポンスが必要なら、JSONP レスポンスインデックス
    に `j` がセットされていなくてはなりません.
  - `sid`: 既にクライアントにセッションIDが渡されているなら、セッションIDをクエリ文字列に
    含める必要があります.
  - `b64`: クライアントが XHR2 をサポートしていないなら、全てのバイナリーデータが base64
    エンコードして送信されるべきであることをサーバーに伝えるために `b64=1` がクエリ文字列に
    含めて送信されます.

*FAQ:* `/engine.io` の部分は変更可能ですか?

サーバーが別のパスセグメントへのリクエストをインターセプトするようにカスタマイズされて
いるなら、yes です.

*FAQ:* オプションがパスの一部になるケースとクエリ文字列の一部としてエンコードされるケースの
違いは何ですか? 別の言葉で言うと、`transport` はなぜ URL の一部ではないのでしょう?

ある Engine.IO サーバーインスタンスによって、リクエストが処理されるべきかどうかを
明らかにする場合に*だけ*、パスのセグメントが使われるというのが規約です.
現状これに該当するのは、Engine.IO のプレフィックス(`/engine.io`) と、リソース (デフォルト
では `default`) だけです.

## エンコーディング

2つの異なるエンコーディングのタイプがあります.

- パケット
- ペイロード

### パケット

エンコードされたパケットは、UTF-8 文字列かバイナリーデータのいずれかです.
文字列の場合のパケットのエンコーディング形式は以下の通りです

```
<パケットタイプID>[<データ>]
```
例:
```
2probe
```
バイナリーデータの場合は、エンコーディングはいつも同じです. バイナリーデータを送信するとき、
パケットタイプIDがバイナリーコンテンツの最初のバイトとして送信され、続いて実際のパケットが
送られます. 例:

```
4|0|1|2|3|4|5
```

上の例では、個々のバイトをパイプ文字列で区切って、整数として表しています. したがって、
上のパケットは message タイプ (後述) であり、0, 1, 2, 3, 4, 5 という値の整数配列に
相当するバイナリーデータを含むということになります.

パケットタイプIDは整数です. 以下は許容されるパケットタイプです.

#### 0 open

新しいトランスポートがオープンされるときに、サーバーから送信されます (再チェック)

#### 1 close

このトランスポートをクローズすることをリクエストしますが、コネクション自体は閉じません.

#### 2 ping

クライアントによって送信されます. サーバーは、同じデータを持つ pong パケットで応答するべきです.

例
1. クライアントからの送信: ```2probe```
2. サーバーからの送信: ```3probe```

#### 3 pong

ping パケットに応答するために、サーバーによって送信されます.

#### 4 message

実際のメッセージです. クライアントおよびサーバーは、データを引数にセットしてコールバックを呼ぶべきです.

##### example 1

1. サーバーからの送信: ```4HelloWorld```
2. クライアントでの受信とコールバックの呼び出し ```socket.on('message', function (data) { console.log(data); });```

##### example 2

1. クライアントからの送信: ```4HelloWorld```
2. サーバーでの受信とコールバックの呼び出し ```socket.on('message', function (data) { console.log(data); });```

#### 5 upgrade

engine.io はトランスポートを切り替える前に、そのトランスポート上でサーバーとクライアントが通信できるかどうかテストします.
このテストが成功したら、クライアントは upgrade パケットを送信して、古いトランスポート上のキャッシュをフラッシュして
新しいトランスポートに切り替えるよう、サーバーにリクエストします.

#### 6 noop

noop パケットです. 主に、新しい websocket 接続が届いたときに、poll サイクルを強制的に実行するために使われます.

##### 例
1. クライアントが新しいトランスポートで接続
2. クライアントからの送信 ```2probe```
3. サーバーが受信して送信 ```3probe```
4. クライアントが受信して送信 ```5```
5. サーバーが以前のトランスポートをフラッシュして閉じ、新しいトランスポートに切り替える.

### ペイロード

ペイロードとは、一連のエンコードされたパケットを結合したものです.
ペイロードのエンコーディング形式は、文字列だけが送信され、XHR2 がサポートされない場合、
以下のようになります.

```
<length1>:<packet1>[<length2>:<packet2>[...]]
```
* length: パケットの__文字__列長
* packet: 上で説明した実際のパケット

XHR2 がサポートされていないければ、バイナリーデータが送信される場合にも同じエンコードの方針
が使われますが、バイナリーデータは base64 エンコードされた文字列として送信されます.
デコードの都合で、`b` という識別子がバイナリーデータを含むエンコードされたパケットの前につきます.
文字列と base64 エンコードされた文字列は、いくつでも組み合わせて送信することが可能です.
base64 でエンコードされたメッセージの例を示します.

```
<base64 形式にしたデータの長さ + 1 (for packet type)>:b<packet1 タイプ><packet1 b64 形式のデータ>[...]
```

XHR2 がサポートされている場合にも、同じような方針が使われますが、全てが直接バイナリーに
エンコードされます.結果として、XHR 上でバイナリーとして送信することができます.
形式は以下の通りです:

```
<文字列データの場合は0, バイナリーデータの場合は1><0から9までの任意の数の数値A><255という値><packet1 (タイプ、データの順)>[...]
```

UTF-8 文字列とバイナリーデータの組み合わせが送信される場合は、文字列は、各文字が文字コードで
バイトに書き込まれるように表現されます.

ペイロードはフレーミングをサポートしないトランスポート (例えば polling プロトコル) で使われます.

## トランスポート

engine.io サーバーは、3つのトランスポートをサポートしなくてはなりません:

- websocket
- flashsocket
- polling
  - jsonp
  - xhr

### polling

polling トランスポートは、クライアントからサーバーへの GET リクエストの繰り返しによる
データ取得と、クライアントからサーバーへのペイロード付き POST リクエストによるデータ送信
からなります.

#### XHR

サーバーは CORS レスポンスをサポートしなくてはなりません.

#### JSONP

サーバー実装は有効な JavaScript を返す必要があります. URL にはクエリ文字列パラメータ `j` が含まれます.
`j` はレスポンスの中で使われていなくてはなりません.
`j` は整数です.

JSONP パケットの形式.

```
`___eio[` <j> `]("` <エンコードされたペイロード> `");`
```

ペイロードが正しく処理されることを保証するために、レスポンスが依然として有効な
JavaScript になるように、ペイロードをエスケープする必要があります.
エンコードされたペイロードを JSONエンコーダーに通すことは、ペイロードをエスケープする
良い方法です.

サーバーが返す JSONP フレームの例:

```
___eio[4]("パケットデータ");
```

##### データのポスト

クライアントは hidden iframe 経由でデータをポストします. データは、以下のような URI
エンコードされた形式でサーバーに届きます:

```
d=<エスケープされたパケットペイロード>
```

通常のクエリ文字列のエスケープに加えて、ブラウザごとの `\n` 処理の違いを防ぐために、
POST される前に、`\n` は `\\n` としてエスケープされます.

### WebSocket

ペイロードをエンコードする方法は、WebSocket では使用するべきではありません. プロトコル
が既に軽量なフレーミングメカニズムを備えているからです.

複数のメッセージからなるペイロードを送信するためには、パケットを個別にエンコードして、それらを順番に
`send()` してください.

## トランスポートのアップグレード

コネクションは常に polling (XHR か JSONP のいずれか) で始まります. WebSocket は、
プロープを送信することによって、別途テストされます. プローブへの応答がサーバーから
返ってきたら、upgrade パケットが送信されます.

メッセージの損失が全くないことを保証するために、既存のトランスポートの全てのバッファーが
フラッシュされ、そのトランスポートが_停止_状態になったとみなされてから、upgrade パケット
が送信されます.

サーバーが upgrade パケットを受信したら、これは新しいトランスポートチャネルであると受け取って、
もし既存のバッファーがあれば、全てそちらに送らなくてはなりません.

クライアントから送信されるプローブは、`probe` がデータとして送信される `ping` パケットです.
サーバーから送信されるプローブは、`probe` がデータとして送信される `pong` パケットです.

将来的に、`polling -> x` 以外のアップグレードを検討する予定です.

## タイムアウト

クライアントは、サーバーが応答しているかどうかを判断するために、ハンドシェイクの一部として
 (`open` パケットとともに) 送信された `pingTimeout` を使わなくてはなりません.

`pingTimeout` の期間内にどのパケットタイプも受信されなかったら、クライアントはソケットが
切断されたとみなします.
